package v8tor

import v8tor.blocks.*
import java.lang.Integer.parseInt
import java.util.*
import java.util.regex.Matcher
import java.util.regex.Pattern
import kotlin.collections.ArrayList

class BytecodeParser(val sc: Scanner){


    var index = -1

    fun parseFunction(): Pair<String, FunctionBlock>{

        val func = FunctionBlock("unset")
        var n = ""
        while(sc.hasNext()) {
            n = getNext()

            if(n.startsWith("[generated bytecode"))
                break

            n = n.trim()

             when{
                 Regex("( )*(\\d+) ([ES])>").containsMatchIn(n) ->{

                     val sourcePosition = parseInt(Regex("( )*(\\d+) ([ES])>").find(n.trim())?.groups?.get(2)?.value)
                     var type = BlockType.Expression

                     when (Regex("( )*(\\d+) ([ES])>").find(n.trim())?.groups?.get(3)?.value) {
                         "E" -> type = BlockType.Expression
                         "S" -> type = BlockType.Statement
                     }

                     func.openBlock(type, sourcePosition)

                     n = n.replace(Regex("( )*\\d+ [ES]>"), "")
                 }
            }

            val address = replaceAndGet("(0x\\w+) @", n)
            n = address.second


            val offset = replaceAndGet("(\\w+) : ", n)
            n = offset.second

            val opcode = replaceAndGet("([0-9a-f]{2} )(([0-9a-f]{2} )*)", n)
            n = opcode.second

            /*print("%s %s %s %s %s \n".format(
                    address.first?.groups?.get(1)?.value,
                    offset.first?.groups?.get(1)?.value,
                    opcode.first?.groups?.get(1)?.value,
                    opcode.first?.groups?.get(2)?.value,
                    n))*/


            val instruction = BytecodeInstruction(
                    address.first?.groups?.get(1)?.value ?: "-1",
                    index,
                    parseInt(opcode.first?.groups?.get(1)?.value?.trim() ?: "0", 16),
                    (opcode.first?.groups?.get(2)?.value ?: "").split(" ")
                            .filter { !it.equals("") }
                            .map { parseInt(it.trim(), 16) }.toTypedArray(),
                    parseInt(opcode.first?.groups?.get(1)?.value?.trim() ?: "0", 16),
                    n
            )

            func.addInstruction(instruction)


        }

        return Pair(n, func)
    }

    private fun replaceAndGet(pattern: String, sentence: String): Pair<MatchResult?, String>{
        val match = Regex(pattern).find(sentence.trim())
        val newSentence = sentence.replace(Regex(pattern), "")

        return Pair(match, newSentence)
    }

    fun parseCompleteBytecode(): ArrayList<FunctionBlock>{

        val result = ArrayList<FunctionBlock>()

        var n = getNext()

        while(sc.hasNext()){

            val next = parseFunction()

            next.second.name = n

            result.add(next.second)

            n = next.first
        }

        return result

    }

    fun getNext(): String{
        index++
        val n = sc.next()

        return n
    }

}